<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `enum_dispatch` crate."><meta name="keywords" content="rust, rustlang, rust-lang, enum_dispatch"><title>enum_dispatch - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="https://gitlab.com/antonok/enum_dispatch/raw/master/enum_dispatch.svg"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../enum_dispatch/index.html'><div class='logo-container'><img src='https://gitlab.com/antonok/enum_dispatch/raw/master/enum_dispatch.svg' alt='logo'></div></a><p class='location'>Crate enum_dispatch</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all enum_dispatch's items</p></a><p class='location'></p><script>window.sidebarCurrent = {name: 'enum_dispatch', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/enum_dispatch/lib.rs.html#1-406' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>enum_dispatch</a></span></h1><div class='docblock'><p><code>enum_dispatch</code> provides a set of macros that can be used to easily refactor dynamically
dispatched trait accesses to improve their performance by up to 10x.</p>
<p>Accessing structures through dynamic dispatch is known to have a high runtime cost. Dynamic
dispatch is traditionally used to hide unnecessary type information, improving encapsulation
and making it trivial to add new implementations. However, this hiding of information means
that each time a structure is dynamically accessed, the program must perform a lookup of the
type's information in a virtual table. The extra round-trips to the vtable quickly add up.</p>
<p>In Rust, dynamic dispatch is done using traits. Rust 2018 adds the <code>impl</code> and <code>dyn</code> keywords to
make it easier to keep track of instances of dynamic dispatch, but it's not always easy to
avoid it entirely.</p>
<h1 id="how-it-works" class="section-header"><a href="#how-it-works">How it works</a></h1>
<p>Observe the following example of code describing a user interface with knobs. Each knob can
hold a value between 0.0 and 1.0. Some knobs provide a <em>linear</em> range, whereas other knobs
provide a <em>logarithmic</em> range.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">trait</span> <span class="ident">KnobControl</span> {
    <span class="kw">fn</span> <span class="ident">set_position</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">value</span>: <span class="ident">f64</span>);
    <span class="kw">fn</span> <span class="ident">get_value</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">f64</span>;
}

<span class="kw">struct</span> <span class="ident">LinearKnob</span> {
    <span class="ident">position</span>: <span class="ident">f64</span>,
}

<span class="kw">struct</span> <span class="ident">LogarithmicKnob</span> {
    <span class="ident">position</span>: <span class="ident">f64</span>,
}

<span class="kw">impl</span> <span class="ident">KnobControl</span> <span class="kw">for</span> <span class="ident">LinearKnob</span> {
    <span class="kw">fn</span> <span class="ident">set_position</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">value</span>: <span class="ident">f64</span>) {
        <span class="self">self</span>.<span class="ident">position</span> <span class="op">=</span> <span class="ident">value</span>;
    }

    <span class="kw">fn</span> <span class="ident">get_value</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">f64</span> {
        <span class="self">self</span>.<span class="ident">position</span>
    }
}

<span class="kw">impl</span> <span class="ident">KnobControl</span> <span class="kw">for</span> <span class="ident">LogarithmicKnob</span> {
    <span class="kw">fn</span> <span class="ident">set_position</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">value</span>: <span class="ident">f64</span>) {
        <span class="self">self</span>.<span class="ident">position</span> <span class="op">=</span> <span class="ident">value</span>;
    }

    <span class="kw">fn</span> <span class="ident">get_value</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">f64</span> {
        (<span class="self">self</span>.<span class="ident">position</span> <span class="op">+</span> <span class="number">1.</span>).<span class="ident">log2</span>()
    }
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="ident">KnobControl</span><span class="op">&gt;</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[
        <span class="comment">//set the knobs</span>
    ];

    <span class="comment">//use the knobs</span>
}</pre></div>
<p>There are other ways to keep an arbitrarily ordered list of different knob types, but none of
them are quite as simple or easy to maintain. Unfortunately, this implementation uses both heap
allocated <code>Box</code>es and dynamic dispatch, which will have performance implications.</p>
<p>One alternative is to use introduce a new enum type that can hold either a <code>LinearKnob</code> or a
<code>LogarithmicKnob</code> as a variant, and also implements <code>KnobControl</code> by matching on itself and
delegating calls to its variants. This would look like the following:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">enum</span> <span class="ident">Knob</span> {
    <span class="ident">Linear</span>(<span class="ident">LinearKnob</span>),
    <span class="ident">Logarithmic</span>(<span class="ident">LogarithmicKnob</span>),
}

<span class="kw">impl</span> <span class="ident">KnobControl</span> <span class="kw">for</span> <span class="ident">Knob</span> {
    <span class="kw">fn</span> <span class="ident">set_position</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">value</span>: <span class="ident">f64</span>) {
        <span class="kw">match</span> <span class="self">self</span> {
            <span class="ident">Knob</span>::<span class="ident">Linear</span>(<span class="ident">inner_knob</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">inner_knob</span>.<span class="ident">set_position</span>(<span class="ident">value</span>),
            <span class="ident">Knob</span>::<span class="ident">Logarithmic</span>(<span class="ident">inner_knob</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">inner_knob</span>.<span class="ident">set_position</span>(<span class="ident">value</span>),
        }
    }

    <span class="kw">fn</span> <span class="ident">get_value</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">f64</span> {
        <span class="kw">match</span> <span class="self">self</span> {
            <span class="ident">Knob</span>::<span class="ident">Linear</span>(<span class="ident">inner_knob</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">inner_knob</span>.<span class="ident">get_value</span>(),
            <span class="ident">Knob</span>::<span class="ident">Logarithmic</span>(<span class="ident">inner_knob</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">inner_knob</span>.<span class="ident">get_value</span>(),
        }
    }
}</pre></div>
<p>Performance with this implementation is significantly improved, since all the information the
program could possibly need to know about each knob can be deduced at compile time. Besides
avoiding heap allocations and vtable lookups, this allows the compiler to squeeze out even more
optimization through function inlining.</p>
<p>However, it's easy to see that the cost of maintaining the source code for this extra structure
is quite high. What happens when we add more knob types? What happens when we add more trait
methods? Even worse, what happens when we do both!</p>
<p>The resulting code is very repetitive, but that makes it a great target for automatic
generation. The <code>enum_dispatch</code> macro can do the automatic generation for you. Examine the code
to generate the same implementation when using <code>enum_dispatch</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">enum_dispatch</span>]</span>
<span class="kw">trait</span> <span class="ident">KnobControl</span> {
    <span class="comment">//...</span>
}

<span class="attribute">#[<span class="ident">enum_dispatch</span>(<span class="ident">KnobControl</span>)]</span>
<span class="kw">enum</span> <span class="ident">Knob</span> {
    <span class="ident">LinearKnob</span>,
    <span class="ident">LogarithmicKnob</span>,
}</pre></div>
<p>That's it. <code>enum_dispatch</code> will also automatically generate implementations of
<code>std::convert::From</code> for each enum variant, so that new <code>Knob</code>s can be created without concern
for the names of each enum variant.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> (<span class="ident">a_linear_knob</span>, <span class="ident">a_logarithmic_knob</span>) <span class="op">=</span> <span class="ident">some_existing_knobs</span>();

<span class="kw">let</span> <span class="ident">knob</span> <span class="op">=</span> <span class="ident">Knob</span>::<span class="ident">from</span>(<span class="ident">a_linear_knob</span>);
<span class="kw">let</span> <span class="ident">knob</span> <span class="op">=</span> <span class="ident">Knob</span>::<span class="ident">from</span>(<span class="ident">a_logarithmic_knob</span>);</pre></div>
<h1 id="performance" class="section-header"><a href="#performance">Performance</a></h1>
<p>The <code>benches</code> directory contains three benchmarks of different natures, each comparing four
different methods of accessing a traited struct of an arbitrary type. The four methods are as
follows:</p>
<table><thead><tr><th>test name</th><th>explanation</th></tr></thead><tbody>
<tr><td>boxdyn</td><td>The easiest way to access a struct, using a heap allocation and dynamic dispatch.</td></tr>
<tr><td>refdyn</td><td>Accesses the struct by reference, but still using dynamic dispatch. No heap allocation.</td></tr>
<tr><td>customderive</td><td>Uses a similar macro approach from the external <a href="https://github.com/DanielKeep/rust-custom-derive"><code>enum_derive</code></a> crate, which implements a method that returns an inner type as a dynamic trait object.</td></tr>
<tr><td>enumdispatch</td><td>Implemented using this crate.</td></tr>
</tbody></table>
<h2 id="the-benchmarks" class="section-header"><a href="#the-benchmarks">The benchmarks</a></h2>
<p>The following benchmark results were measured on a Ryzen 7 2700x CPU.</p>
<h3 id="compiler_optimized" class="section-header"><a href="#compiler_optimized">compiler_optimized</a></h3>
<p>The first set of benchmarks creates trait objects and measures the speed of accessing a method
on them.</p>
<pre><code class="language-text">test benches::boxdyn_compiler_optimized       ... bench:   2,135,418 ns/iter (+/- 12,575)
test benches::customderive_compiler_optimized ... bench:   2,611,860 ns/iter (+/- 18,644)
test benches::enumdispatch_compiler_optimized ... bench:           0 ns/iter (+/- 0)
test benches::refdyn_compiler_optimized       ... bench:   2,132,591 ns/iter (+/- 22,114)
</code></pre>
<p>It's easy to see that <code>enum_dispatch</code> is the clear winner here!</p>
<p>Ok, fine. This wasn't a fair test. The compiler is able to &quot;look through&quot; the trait method call
in the enum_dispatch case, notices that the result is unused, and removes it as an
optimization. However, this still highlights an important property of <code>enum_dispatch</code>ed types:
the compiler is able to infer much better optimizations when possible.</p>
<h3 id="blackbox" class="section-header"><a href="#blackbox">blackbox</a></h3>
<p>The next set of benchmarks uses the <code>test::black_box</code> method to hide the fact that the result
of the method is unused.</p>
<pre><code class="language-text">test benches::boxdyn_blackbox       ... bench:   2,131,736 ns/iter (+/- 24,937)
test benches::customderive_blackbox ... bench:   2,611,721 ns/iter (+/- 23,502)
test benches::enumdispatch_blackbox ... bench:     471,740 ns/iter (+/- 1,439)
test benches::refdyn_blackbox       ... bench:   2,131,978 ns/iter (+/- 21,547)
</code></pre>
<p>The competitors faced virtually no impact, whereas <code>enum_dispatch</code> takes the full force of the
<code>black_box</code> call. This test shows the power that avoiding dynamic dispatch gives to the
compiler in the context of the previous test, but also demonstrates how much faster
<code>enum_dispatch</code> is in real code: almost 5 times faster than the closest alternative.</p>
<h3 id="homogenous_vec" class="section-header"><a href="#homogenous_vec">homogenous_vec</a></h3>
<p>The final set of benchmarks puts 1024 traited structs of arbitrary types at random into a <code>Vec</code>
and measures the time it takes to successively iterate over the entire <code>Vec</code>, calling
<code>black_box</code>ed methods on each element.</p>
<pre><code class="language-text">test benches::boxdyn_homogeneous_vec       ... bench:   5,900,191 ns/iter (+/- 95,169)
test benches::customderive_homogeneous_vec ... bench:   4,831,808 ns/iter (+/- 140,437)
test benches::enumdispatch_homogeneous_vec ... bench:     479,630 ns/iter (+/- 3,531)
test benches::refdyn_homogeneous_vec       ... bench:   5,658,461 ns/iter (+/- 137,128)
</code></pre>
<p>This might be one of the most likely use cases for traited structs of arbitrary types, and it's
where <code>enum_dispatch</code> really shines. Since a <code>Vec</code> of <code>enum_dispatch</code> objects is actually a
<code>Vec</code> of enums rather than addresses, accessing an element takes half the indirection of the
other techniques. Add that to the lack of vtable accesses, and we have a result that is 10
times faster than the closest alternative, and almost 12 times faster than the best technique
from the standard library.</p>
</div><h2 id='attributes' class='section-header'><a href="#attributes">Attribute Macros</a></h2>
<table><tr class='module-item'><td><a class="attr" href="attr.enum_dispatch.html" title='enum_dispatch::enum_dispatch attr'>enum_dispatch</a></td><td class='docblock-short'><p>Annotating a trait or enum definition with an <code>#[enum_dispatch]</code> attribute will register it
with the enum_dispatch library, allowing it to be used to generate impl blocks elsewhere.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "enum_dispatch";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>